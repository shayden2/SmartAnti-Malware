from collections import defaultdict
import pefile
import os
import csv

def determine_file_type(reader, filename):
    for row in reader:
        if str(row[0]) == str(filename):
            return str(row[6])
    return 'Not Found'

def main():
    file_data = open('../malware/train.csv', 'r')
    reader = csv.reader(file_data)

    imports_blacklist = defaultdict(int)
    functions_blacklist = defaultdict(int)
    imports_whitelist = defaultdict(int)
    functions_whitelist = defaultdict(int)

    import_file_blacklist = open('../outputs/imports_blacklist.csv', 'w')
    import_file_whitelist = open('../outputs/imports_whitelist.csv', 'w')
    writer_import_blacklist = csv.writer(import_file_blacklist, delimiter=',')
    writer_import_whitelist = csv.writer(import_file_whitelist, delimiter=',')

    function_file_blacklist = open('../outputs/functions_blacklist.csv', 'w')
    function_file_whitelist = open('../outputs/function_whitelist.csv', 'w')
    writer_function_blacklist  = csv.writer(function_file_blacklist, delimiter=',')
    writer_function_whitelist = csv.writer(function_file_whitelist, delimiter=',')
    
    problems_file = open('../outputs/problems.csv', 'w')
    writer_problems = csv.writer(problems_file, delimiter=',')
   
    files = os.listdir('../malware/train')
    l = len(files)
    counter = 1
    
    t = defaultdict(str)
    for row in reader:
        t[str(row[0])] = str(row[6])

    for file in files:
        print(f'Processing {counter}/{l}')
        counter += 1

        # Determine Black/Whitelist
        file_type = t[str(file)]
        if str(file) not in t:
            writer_problems.writerow([file, 'Not found in train.csv'])
            continue

        # Get .dlls and add to proper dict
        try:
            pe = pefile.PE(f'../malware/train/{file}', fast_load = True)
            pe.parse_data_directories()
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                try:
                    dll = entry.dll.decode().lower()
                    if file_type == 'Blacklist':
                        imports_blacklist[dll] += 1
                    else:
                        imports_whitelist[dll] += 1
                    for func in entry.imports:
                        try:
                            function = f'{dll}/{func.name.decode().lower()}'
                            if file_type == 'Blacklist':
                                functions_blacklist[function] += 1
                            else:
                                functions_whitelist[function] += 1
                        except:
                            pass
                except:
                    writer_problems.writerow([file, 'Couldnt readi imports'])
        except:
            writer_problems.writerow([file, 'Cant load dlls'])

    for dll in imports_blacklist:
        writer_import_blacklist.writerow([dll, imports_blacklist[dll]])
    for dll in imports_whitelist:
        writer_import_whitelist.writerow([dll, imports_whitelist[dll]])
    for func in functions_blacklist:
        writer_function_blacklist.writerow([func, functions_blacklist[func]])
    for func in functions_blacklist:
        writer_function_whitelist.writerow([func, functions_whitelist[func]])
    
    import_file_blacklist.close()
    import_file_whitelist.close()
    function_file_blacklist.close()
    function_file_whitelist.close()


if __name__ == '__main__':
    main()
'''
import pefile
from collections import defaultdict
import os
import csv

def main():
    importsz = defaultdict(int)
    functions = defaultdict(int)
    import_file = open('outputs/imports.csv', 'w')
    function_file = open('outputs/functions.csv', 'w')
    problems_file = open('outputs/problems.txt', 'w')

    writer_import  = csv.writer(import_file, delimiter=',')
    writer_function  = csv.writer(function_file, delimiter=',')

    files = os.listdir('malware/train')
    l = len(files)
    counter = 1
    for file in files:
        print(f'Processing {counter}/{l}')
        counter += 1
        try:
            pe = pefile.PE('malware/train/'+file, fast_load = True)
            pe.parse_data_directories()
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                try:
                    imports[f'{entry.dll.decode().lower()}'] += 1
                except:
                    pass
                for func in entry.imports:
                    try:
                        functions[f'{entry.dll.decode().lower()}/{func.name.decode().lower()}'] += 1 
                    except:
                        pass
        except:
            problems_file.write(f'{file}\n')
    
    for entry in functions:
        writer_function.writerow([entry, functions[entry]])
    for dll in imports:
        writer_import.writerow([dll, imports[dll]])

    import_file.close()
    function_file.close() 

if __name__ == '__main__':
    main()
'''